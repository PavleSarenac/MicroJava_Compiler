package rs.ac.bg.etf.pp1;
 
import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;
 
parser code {:
	private Logger logger = Logger.getLogger(getClass());
	private boolean isErrorDetected = false;
 
	public boolean isSyntaxAnalysisErrorDetected() {
		return isErrorDetected;
	}
	
    public void report_error(String message, Object info) {
    	isErrorDetected = true;
		int errorLineNumber = -1;
		if (info instanceof Symbol) {
			errorLineNumber = ((Symbol)info).left;
		} else if (info instanceof Integer) {
			errorLineNumber = (int)info;
		}
		if (errorLineNumber == -1) {
			logger.error(message);
		} else {
			logger.error(message + " (line " + errorLineNumber + ").");
		}
    }
    
    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error", cur_token);
    }
    
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal error, parsing must be stopped", cur_token);
    }
    
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
:}
 
scan with {:
	Symbol symbol = this.getScanner().next_token();
	if (symbol != null && symbol.value != null) {
		logger.info("New token created(token class id: '" + symbol + "'; token value: '" + symbol.value.toString() + "').");
	} else if (symbol != null) {
		logger.info("New token created(token class id: '" + symbol + "').");
	}
	return symbol;
:}
 
terminal PROGRAM, BREAK, CONST, ELSE, IF, NEW, PRINT, READ, RETURN, VOID, CONTINUE, FOR;
terminal PLUS, MINUS, MULTIPLY, DIVIDE, MODULO, EQUALS, NOT_EQUALS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LESS_THAN, LESS_THAN_OR_EQUAL, LOGICAL_AND, LOGICAL_OR, ASSIGN, INCREMENT, DECREMENT, SEMICOLON, COLON, COMMA, LEFT_PARENTHESES, RIGHT_PARENTHESES, LEFT_BRACKET, RIGHT_BRACKET, LEFT_BRACE, RIGHT_BRACE;
terminal NUMBER, BOOLEAN, CHARACTER, IDENTIFICATOR;
 
nonterminal Program, ConstDecl, Type, VarDecl, MethodDecl, FormPars;
nonterminal GlobalDeclList, GlobalDecl;
nonterminal ConstDeclList, ConstDeclElement, Const; 
nonterminal VarDeclList, VarDeclElement; 
nonterminal ArrayBrackets, OneDimenisonalArrayBrackets, TwoDimensionalArrayBrackets;
nonterminal MethodDeclList, MethodReturnType, MethodFormalParameters, TypedVarDeclElement, MethodVariableDeclarations;

Program ::= PROGRAM IDENTIFICATOR GlobalDeclList LEFT_BRACE MethodDeclList RIGHT_BRACE;
 
GlobalDeclList ::= GlobalDeclList GlobalDecl
                 | /* epsilon */;
                 
GlobalDecl ::= ConstDeclList
             | VarDeclList;

ConstDeclList ::= CONST Type ConstDecl SEMICOLON;

Type ::= IDENTIFICATOR;

ConstDecl ::= ConstDecl COMMA ConstDeclElement
            | ConstDeclElement;
                
ConstDeclElement ::= IDENTIFICATOR ASSIGN Const;

Const ::= NUMBER
        | CHARACTER
        | BOOLEAN;
        
VarDeclList ::= Type VarDecl SEMICOLON;

VarDecl ::= VarDecl COMMA VarDeclElement
          | VarDeclElement;
              
VarDeclElement ::= IDENTIFICATOR ArrayBrackets;

ArrayBrackets ::= OneDimenisonalArrayBrackets
                | TwoDimensionalArrayBrackets
                | /* epsilon */;
                
OneDimenisonalArrayBrackets ::= LEFT_BRACKET RIGHT_BRACKET;

TwoDimensionalArrayBrackets ::= OneDimenisonalArrayBrackets OneDimenisonalArrayBrackets;

MethodDeclList ::= MethodDeclList MethodDecl
                 | /* epsilon */;

MethodDecl ::= MethodReturnType IDENTIFICATOR LEFT_PARENTHESES MethodFormalParameters RIGHT_PARENTHESES MethodVariableDeclarations LEFT_BRACE RIGHT_BRACE;

MethodReturnType ::= Type
                   | VOID;
                   
MethodFormalParameters ::= FormPars
                         | /* epsilon */;
                         
FormPars ::= FormPars COMMA TypedVarDeclElement
               | TypedVarDeclElement;
               
TypedVarDeclElement ::= Type VarDeclElement;
                         
MethodVariableDeclarations ::= VarDecl
                             | /* epsilon */;